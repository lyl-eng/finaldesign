# 自定义工作流实现说明

## 工作流实现方式

虽然代码中提到了Griptape框架，但**实际使用的是完全自定义的工作流实现**，通过Python的简单函数调用和字典数据传递来实现。

## 核心实现原理

### 1. 工作流管理器（WorkflowManager）

工作流通过 `WorkflowManager.execute_workflow()` 方法实现，采用**顺序执行 + 数据传递**的方式：

```python
def execute_workflow(self, cache_project, ...):
    # 阶段1: 直接调用Agent
    preprocessing_result = self.preprocessing_agent.execute({
        "cache_project": cache_project
    })
    
    # 提取结果数据
    cache_project = preprocessing_result["cache_project"]
    metadata = preprocessing_result.get("metadata", {})
    
    # 阶段2: 使用阶段1的结果，调用下一个Agent
    terminology_result = self.terminology_agent.execute({
        "cache_project": cache_project,  # 传递更新后的数据
        "metadata": metadata              # 传递元数据
    })
    
    # 提取结果数据
    terminology_db = terminology_result.get("terminology_database", {})
    memory_storage = terminology_result.get("memory_storage", {})
    
    # 阶段3: 使用前两个阶段的结果
    translation_result = self.translation_agent.execute({
        "cache_project": cache_project,
        "terminology_database": terminology_db,  # 传递术语库
        "memory_storage": memory_storage         # 传递Memory
    })
    
    return workflow_result
```

## 实现架构

### Agent接口设计

所有Agent都继承自`BaseAgent`，实现统一的`execute()`接口：

```python
class BaseAgent(ABC):
    @abstractmethod
    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        统一的执行接口
        输入: 字典（包含所需数据）
        输出: 字典（包含处理结果）
        """
        pass
```

### 数据流转方式

```
输入: cache_project
  ↓
[PreprocessingAgent.execute()]
  ├─ 输入: {"cache_project": cache_project}
  ├─ 处理: 文本拆解、风格识别
  └─ 输出: {"cache_project": 更新后的, "metadata": {...}}
  ↓
提取: cache_project, metadata
  ↓
[TerminologyEntityAgent.execute()]
  ├─ 输入: {"cache_project": ..., "metadata": ...}
  ├─ 处理: 术语识别、知识库查证
  └─ 输出: {"cache_project": ..., "terminology_database": {...}, "memory_storage": {...}}
  ↓
提取: cache_project, terminology_db, memory_storage
  ↓
[TranslationRefinementAgent.execute()]
  ├─ 输入: {"cache_project": ..., "terminology_database": ..., "memory_storage": ...}
  ├─ 处理: 翻译、优化、回译验证
  └─ 输出: {"cache_project": 最终结果, "translation_results": [...]}
  ↓
最终结果
```

## 关键特性

### 1. 顺序执行

```python
# WorkflowManager.py 第84-181行
# 严格按照顺序执行，每个阶段等待前一个阶段完成

# 阶段1
preprocessing_result = self.preprocessing_agent.execute(...)
if not preprocessing_result.get("success"):
    return workflow_result  # 失败则停止

# 阶段2（依赖阶段1的结果）
terminology_result = self.terminology_agent.execute(...)
if not terminology_result.get("success"):
    return workflow_result  # 失败则停止

# 阶段3（依赖阶段1和2的结果）
translation_result = self.translation_agent.execute(...)
```

### 2. 数据传递

通过Python字典在Agent之间传递数据：

```python
# 输入数据
input_data = {
    "cache_project": cache_project,
    "metadata": metadata,
    "terminology_database": terminology_db
}

# Agent处理
result = agent.execute(input_data)

# 提取输出数据
output_data = result.get("cache_project")
```

### 3. 错误处理

每个阶段都有错误检查：

```python
if not preprocessing_result.get("success"):
    self.error("译前预处理失败")
    return workflow_result  # 立即停止工作流
```

### 4. 人工介入节点

在关键节点检查是否需要人工介入：

```python
if human_intervention_callback:
    intervention_result = self._check_human_intervention(...)
    if intervention_result:
        # 处理人工输入
        ...
```

## 与Griptape的对比

### Griptape方式（未使用）

```python
# 如果使用Griptape，可能是这样：
workflow = Workflow()
workflow.add_task(PromptTask("预处理任务", ...))
workflow.add_task(PromptTask("术语识别任务", ...))
workflow.add_task(PromptTask("翻译任务", ...))
result = workflow.run()
```

### 当前自定义方式（实际使用）

```python
# 当前实现方式：
result1 = preprocessing_agent.execute(input1)
result2 = terminology_agent.execute(result1)
result3 = translation_agent.execute(result2)
```

## 优势

### 1. 简单直接
- ✅ 代码清晰，易于理解
- ✅ 没有额外的框架依赖
- ✅ 调试方便

### 2. 完全控制
- ✅ 可以精确控制执行顺序
- ✅ 可以自定义错误处理
- ✅ 可以灵活添加人工介入节点

### 3. 易于扩展
- ✅ 添加新Agent只需实现`execute()`方法
- ✅ 修改工作流顺序只需调整调用顺序
- ✅ 不需要学习Griptape框架

## 工作流执行流程图

```
开始
  ↓
[WorkflowManager.execute_workflow()]
  ↓
┌─────────────────────────────────┐
│ 阶段1: PreprocessingAgent       │
│ execute({"cache_project": ...})  │
│  ↓                               │
│ 返回: {                           │
│   "cache_project": 更新后的,     │
│   "metadata": {...}              │
│ }                                │
└─────────────────────────────────┘
  ↓ 提取数据
┌─────────────────────────────────┐
│ 阶段2: TerminologyEntityAgent   │
│ execute({                        │
│   "cache_project": ...,          │
│   "metadata": ...                │
│ })                               │
│  ↓                               │
│ 返回: {                           │
│   "cache_project": 更新后的,     │
│   "terminology_database": {...}, │
│   "memory_storage": {...}        │
│ }                                │
└─────────────────────────────────┘
  ↓ 提取数据
┌─────────────────────────────────┐
│ 阶段3: TranslationRefinementAgent│
│ execute({                        │
│   "cache_project": ...,          │
│   "terminology_database": ...,   │
│   "memory_storage": ...          │
│ })                               │
│  ↓                               │
│ 返回: {                           │
│   "cache_project": 最终结果,     │
│   "translation_results": [...]  │
│ }                                │
└─────────────────────────────────┘
  ↓
完成
```

## 总结

**当前工作流实现方式**：

1. ✅ **顺序执行**：通过Python函数调用实现
2. ✅ **数据传递**：通过字典在Agent之间传递
3. ✅ **错误处理**：每个阶段检查成功/失败
4. ✅ **人工介入**：在关键节点检查是否需要人工审核
5. ✅ **完全自定义**：不依赖任何工作流框架

这是一个**简单但有效**的工作流实现方式，虽然没有使用Griptape框架，但完全实现了多智能体工作流的功能！

