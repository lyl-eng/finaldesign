# 批量翻译失败问题排查与解决

## 问题时间
2025-12-28

## 问题描述

在多智能体批量翻译过程中，部分批次出现翻译失败：

```
[WARNING] ⚠️ 翻译结果数量不匹配: 期望12行，实际0行
[WARNING] 批次 1 翻译失败或结果数量不匹配

[WARNING] ⚠️ 翻译结果数量不匹配: 期望10行，实际0行
[WARNING] 批次 7 翻译失败或结果数量不匹配
```

### 问题原因

批量翻译时，系统要求LLM返回JSON数组格式：

```json
["译文1", "译文2", "译文3", ...]
```

但是LLM可能返回：
1. ❌ 非JSON格式（纯文本）
2. ❌ JSON格式不标准（有注释、多余逗号等）
3. ❌ JSON数组中元素数量不匹配
4. ❌ 包含了额外的说明文字

导致 `_extract_batch_translations` 方法无法正确解析。

---

## 解决方案

### 1. 增强JSON解析能力

实现了**三层解析策略**：

#### 策略1: 提取代码块中的JSON
```python
# 查找 ```json ... ``` 或 ``` ... ``` 代码块
json_match = re.search(r'```(?:json)?\s*(\[.*?\])\s*```', response, re.DOTALL)
```

#### 策略2: 直接查找JSON数组
```python
# 从响应中找到 [...] 部分
json_start = response.find("[")
json_end = response.rfind("]") + 1
# 修复常见的JSON格式问题
json_str = re.sub(r'//.*?\n', '', json_str)  # 移除单行注释
json_str = re.sub(r'/\*.*?\*/', '', json_str, flags=re.DOTALL)  # 移除块注释
```

#### 策略3: 按行分割提取
```python
# 逐行处理，移除序号、引号、逗号
lines = response.strip().split("\n")
for line in lines:
    line = line.strip()
    line = re.sub(r'^\d+[\.\)]\s*', '', line)  # 移除序号
    line = line.strip('",\'')  # 移除引号
    translations.append(line)
```

### 2. 添加降级机制

如果批量翻译的JSON解析完全失败，**自动降级为逐行翻译**：

```python
# 批量翻译失败时
self.warning("⚡ 批量翻译失败，尝试逐行翻译模式...")
return self._fallback_to_sequential_translation(
    source_texts, context_texts, terminology_db, memory_storage
)
```

**逐行翻译**的好处：
- ✅ 不需要JSON格式，直接返回译文
- ✅ 更稳定，失败率低
- ✅ 只影响当前失败的批次

**逐行翻译**的代价：
- ⚠️ 该批次的API调用次数增加（从1次变为N次）
- ⚠️ 该批次的翻译时间增加

### 3. 增强错误日志

现在会显示：
- ✅ LLM返回的原始响应（前500-1000字符）
- ✅ JSON解析的每个步骤
- ✅ 提取到的译文数量和内容
- ✅ 失败原因的详细描述

```
[ERROR] ❌ 翻译结果数量不匹配: 期望12行，实际0行
[ERROR] LLM原始响应: {"思考过程": "...", "译文": [...]}
[WARNING] ⚡ 批量翻译失败，尝试逐行翻译模式...
[INFO] 开始逐行翻译 12 个文本...
[INFO] [1/12] 正在翻译...
[INFO] ✓ 行1: 这是第一行译文...
...
```

---

## 现在的工作流程

```
📦 批次翻译开始
   ↓
🌐 调用LLM（批量翻译，1次API）
   ↓
🔍 尝试解析JSON（三层策略）
   ├─ ✅ 解析成功 → 继续多版本融合
   └─ ❌ 解析失败 → 降级逐行翻译
                     ↓
              🔄 逐行翻译（N次API）
                     ↓
              ✅ 继续多版本融合
```

---

## 预期效果

### 批量翻译成功（大多数情况）
```
📦 批次 [1/11] - 正在批量翻译 12 个文本单元
  步骤1: 批量翻译
     🌐 调用 LLM API 进行批量翻译（12 行）...
     ⏳ LLM响应已接收，正在解析...
     ✅ 解析成功: 12 行译文
     📝 译文示例: 这是一个示例...
  
  步骤2: 多版本融合（12行）
  步骤3: 回译验证（12行）
  ✅ 批次完成
```

**API调用**：1次（批量翻译） + 约36-48次（多版本融合） + 约24-36次（回译验证） = **61-85次**

### 批量翻译失败，降级逐行（少数情况）
```
📦 批次 [1/11] - 正在批量翻译 12 个文本单元
  步骤1: 批量翻译
     🌐 调用 LLM API 进行批量翻译（12 行）...
     ⏳ LLM响应已接收，正在解析...
     ❌ 翻译结果数量不匹配: 期望12行，实际0行
     ⚡ 批量翻译失败，尝试逐行翻译模式...
     开始逐行翻译 12 个文本...
     [1/12] 正在翻译...
     ✓ 行1: 这是第一行译文...
     ...
     ✅ 逐行翻译完成: 12 行
  
  步骤2: 多版本融合（12行）
  步骤3: 回译验证（12行）
  ✅ 批次完成
```

**API调用**：1次（失败的批量） + 12次（逐行翻译） + 约36-48次（多版本融合） + 约24-36次（回译验证） = **73-97次**

---

## 改进的代码位置

### 1. 增强错误日志
`ModuleFolders/MultiAgent/TranslationRefinementAgent.py` - `_multi_step_batch_translation` 方法（516-532行）

```python
if not skip and response_content:
    self.info("     ⏳ LLM响应已接收，正在解析...")
    self.debug(f"     LLM响应内容（前500字符）: {response_content[:500]}")
    
    translated_texts = self._extract_batch_translations(response_content, len(source_texts))
    if translated_texts and len(translated_texts) == len(source_texts):
        # 成功
        return translated_texts
    else:
        # 失败，显示错误并降级
        self.error(f"     ❌ 翻译结果数量不匹配: 期望{len(source_texts)}行，实际{len(translated_texts) if translated_texts else 0}行")
        self.error(f"     LLM原始响应: {response_content[:1000]}")
        self.warning("     ⚡ 批量翻译失败，尝试逐行翻译模式...")
        return self._fallback_to_sequential_translation(...)
```

### 2. 降级逐行翻译
`ModuleFolders/MultiAgent/TranslationRefinementAgent.py` - `_fallback_to_sequential_translation` 方法（新增）

```python
def _fallback_to_sequential_translation(self, source_texts, context_texts, 
                                        terminology_db, memory_storage):
    """降级方案：批量翻译失败时，逐行翻译"""
    translated_texts = []
    for idx, source_text in enumerate(source_texts, 1):
        # 单条翻译逻辑（不需要JSON格式）
        translated_text = self._translate_single_text(...)
        translated_texts.append(translated_text)
    return translated_texts
```

### 3. 增强JSON解析
`ModuleFolders/MultiAgent/TranslationRefinementAgent.py` - `_extract_batch_translations` 方法（改进）

```python
def _extract_batch_translations(self, response, expected_count):
    """三层解析策略"""
    # 策略1: 提取代码块中的JSON
    # 策略2: 直接查找JSON数组（修复常见格式问题）
    # 策略3: 按行分割提取
    # 允许小误差（±2行）
```

---

## 建议的Prompt优化

为了减少批量翻译失败率，可以在System Prompt中更明确地强调JSON格式：

```python
system_prompt = f"""你是一位专业的翻译专家。请按照以下步骤进行翻译：

步骤1 - 理解：分析原文的语义、语境和风格
步骤2 - 分解：对于长难句，先识别主干成分和从句层级
步骤3 - 转换：将原文转换为目标语言，保持语义准确
步骤4 - 润色：优化译文，确保流畅自然

{terminology_prompt}
{memory_context}

**重要：必须严格遵守以下格式要求**
1. 只返回JSON数组，不要返回其他任何内容
2. 不要添加说明文字、思考过程或注释
3. 数组中的元素数量必须与原文行数完全一致
4. 每个译文作为数组的一个字符串元素

**正确格式示例：**
["译文1", "译文2", "译文3"]

**错误格式（不要这样）：**
- 带有说明文字：这是翻译结果：["译文1", "译文2"]
- 带有注释：["译文1", // 这是第一行
- 带有思考过程：思考："译文1", "译文2"]
"""
```

---

## 监控与调试

### 启用DEBUG日志查看详细解析过程

如果想查看更详细的解析过程，可以在配置中启用DEBUG级别日志：

```python
import logging
logging.getLogger('TranslationRefinementAgent').setLevel(logging.DEBUG)
```

### 关键指标

监控以下指标来评估系统稳定性：

| 指标 | 说明 | 目标值 |
|-----|------|--------|
| **批量翻译成功率** | 成功解析JSON的批次比例 | >90% |
| **降级率** | 需要降级为逐行翻译的批次比例 | <10% |
| **平均API调用次数/批次** | 包括降级的额外调用 | 61-97次 |

---

## 总结

### 问题
批量翻译时LLM返回的JSON格式无法解析，导致翻译失败。

### 解决
1. ✅ 增强JSON解析能力（三层策略）
2. ✅ 添加降级机制（自动切换到逐行翻译）
3. ✅ 增强错误日志（显示原始响应和详细错误）
4. ✅ 允许小误差（±2行）自动调整

### 效果
- ✅ 批量翻译失败不会导致整个批次失败
- ✅ 自动降级保证翻译质量
- ✅ 详细日志便于排查问题
- ✅ 系统更加健壮和稳定

**现在即使批量翻译解析失败，系统也会自动降级为逐行翻译，确保翻译任务能够完成！** 🎉

